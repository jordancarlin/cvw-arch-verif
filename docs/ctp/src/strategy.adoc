
== General Test Plan Strategy

This CTP describes tests for all supported RISC-V profiles, but the tests run on a specific DUT.
The DUT configuration is described with RISC-V Unified Database, and supplementary files such as
simulator configuration files are automatically generated from the UDB so there is a single
configuration file to maintain.  The UDB describes the supported extensions, and also has parameters
defining optional behaviors of those extensions.  If a behavior is UNSPECIFIED in the specification,
it is not tested because there are no wrong answers.  A common purpose of parameters is to define the
behavior of WARL fields in CSRs.

=== Configuration

The DUT is described with a https://github.com/riscv-software-src/riscv-unified-db[Unified Database] (UDB) YAML file.
This file lists:

* all of the supported extensions
* all of the parameters required to describe the behavior of the extensions

The DUT also needs to know how to boot the core, terminate a test with a success code, send a message to a console, and cause interrupts.  These DUT-specific behaviors are described by a <<Trick Box, Trick Box>>, which is an assembly-language library implementing an API using DUT-specific hardware.

*** is a linker script really needed?  For PMP?

=== Unified Database

Unified Database allows _partially-_ and _fully-configured descriptions_.  A profile is an example of a partially configured description because it has a mix of required and optional extensions, and does not specify parameter values for most of the extensions.  A DUT needs to have a fully configured description including precisely which versions of which extensions are supported and what parameter values are implemented, so that a simulator can exactly match its behavior.

The <<Framework,certification framework>> requires a fully-configured UDB description of the DUT and a trick box for the DUT.
It uses UDB to produce supplementary configuration files including:

* Sail JSON file configuring reference model to match DUT
* Configuration files for other optional simulators, such as Spike, https://github.com/openhwgroup/cvw/blob/main/config/rv64gc/imperas.ic[ImperasFPM]
* SystemVerilog coverage.svh file describing which coverage files and parameter values to use for coverage measurement
* Optional DUT configuration files https://github.com/openhwgroup/cvw/blob/main/config/rv64gc/coverage.svh[(CORE-V Wally Example)] providing parameter values to configurable RTL

==== Configuration Parameters

The UDB parameters for each extension are defined in:

https://github.com/riscv-software-src/riscv-unified-db/tree/main/spec/std/isa/ext

*** The CSC Tests and Models working group developed the following list of configuration parameters.
Need to check if they match the parameters in UDB extensions.

https://docs.google.com/spreadsheets/d/1tFGLbocTp1YNn11aN8JTmvxL_23e7x8SlBNJfOPRmAE/edit?gid=0#gid=0

A partially-configured UDB description of each profile is given in:

* https://riscv-software-src.github.io/riscv-unified-db/resolved_arch/profile/RVI20U32.yaml[RVI20U32]
* https://riscv-software-src.github.io/riscv-unified-db/resolved_arch/profile/RVI20U64.yaml[RVI20U64]
* https://github.com/riscv-software-src/riscv-unified-db/blob/main/cfgs/mc100-32-full-example.yaml[MC100]
* https://riscv-software-src.github.io/riscv-unified-db/resolved_arch/profile/RVA22S64.yaml[RVA22S64]
* https://riscv-software-src.github.io/riscv-unified-db/resolved_arch/profile/RVB23S64.yaml[RVB23S64]
* https://riscv-software-src.github.io/riscv-unified-db/resolved_arch/profile/RVA23S64.yaml[RVA23S64]

*** add minimal and maximal fully configured flavors of these profiles in riscv-arch-test, with no and all optional features, and suitable parameters.

=== Unspecified and Reserved Behaviors

Some RISC-V behaviors are UNSPECIFIED, which means an implementation can do anything. These behaviors are not tested because there is no wrong answer. <<t-behavior-normative-rules>> summarizes the normative rules regarding reserved behaviors.

Unimplemented opcodes (except in the custom space) and instructions accessing non-existent CSRs are reserved.  The behavior of reserved instructions is UNSPECIFIED, so they should not be tested by most testplans.  However, when the Ssstrict extension is enabled, reserved instructions raise an illegal instruction exception that results in a contained trap to the supervisor-mode trap handler.  This is tested by the Ssstrict test plan.

[[t-behavior-normative-rules]]
.I Normative Rules Regarding Behaviors
[cols="1, 4" options=header]
|===
|Spec Section|Normative Rule
|Unpriv 1.7|The term UNSPECIFIED refers to a behavior or value that is intentionally unconstrained.
|Unpriv 2.2|For this purpose, we divide each RISC-V
instruction-set encoding space (and related encoding spaces such as the CSRs) into three disjoint
categories: standard, reserved, and custom. ... Reserved encodings are currently not defined but are saved for future standard extensions; once thus used, they become standard encodings. ... The behavior upon decoding a reserved instruction is UNSPECIFIED.
|Privileged 2.1|Instructions that access a non-existent CSR are reserved.
|https://github.com/riscv/riscv-profiles/blob/main/src/rva23-profile.adoc#rva23s64-profile[rva23-profile]|Ssstrict No non-conforming extensions are present. Attempts to execute unimplemented opcodes or access unimplemented CSRs in the standard or reserved encoding spaces raises an illegal instruction exception that results in a contained trap to the supervisor-mode trap handler.
|===

=== CSR Bitfields

CSR fields can be Write Preserves, Read Ignores (WPRI), Write Legal, Read Legal (WLRL), or Write Any, Read Legal (WARL). Examples of WPRI fields include undefined fields of `xstatus`, `xenvcfg`, `mseccfg`, and `xstateen*` that could have unintended side effects if they are subsequently defined and unwittingly set to nonzero values. Examples of WLRL fields include `xcause.ExceptionCode` and `hstatus.VGEIN`.  Other CSR fields are generally WARL.

WPRI fields are not tested. WLRL fields are tested with all legal values but no illegal values.   WARL fields are tested by trying all possible values of the field.  CSR tests (<<Zicsr>>) generally involve setting all bits to 1, setting all to 0, and writing walking 1s.   Therefore, they inherently exercise all possible values of 1 and 2-bit WARL fields.  Longer fields can be tested exhaustively if the number of possibilities is small (such as `satp.MODE`), or just with walking 1s if the number of possibilities is too large (such as `misa.EXTENSIONS`).

<<t-bitfield-normative-rules>> summarizes the normative rules regarding CSR bitfields.

[[t-bitfield-normative-rules]]
.I Normative Rules Regarding Bitfields
[cols="1, 4" options=header]
|===
|Spec Section|Normative Rule
|Privileged 2.3|Some whole read/write fields are reserved for future use. Software should ignore the values read from
these fields, and should preserve the values held in these fields when writing values to other fields of
the same register. For forward compatibility, implementations that do not furnish these fields must
make them read-only zero. These fields are labeled *WPRI* in the register descriptions.
|Privileged 2.3|Some read/write CSR fields specify behavior for only a subset of possible bit encodings, with other bit encodings reserved. Software should not write anything other than legal values to such a field, and
should not assume a read will return a legal value unless the last write was of a legal value, or the
register has not been written since another operation (e.g., reset) set the register to a legal value.
These fields are labeled *WLRL* in the register descriptions.
|Privileged 2.3|Implementations are permitted but not required to raise an illegal-instruction exception if an
instruction attempts to write a non-supported value to a *WLRL* field. Implementations can return
arbitrary bit patterns on the read of a *WLRL* field when the last write was of an illegal value, but the
value returned should deterministically depend on the illegal written value and the value of the field
prior to the write.
|Privileged 2.3|Some read/write CSR fields are only defined for a subset of bit encodings, but allow any value to be
written while guaranteeing to return a legal value whenever read. Assuming that writing the CSR has no
other side effects, the range of supported values can be determined by attempting to write a desired
setting then reading to see if the value was retained. These fields are labeled *WARL* in the register
descriptions.
|Privileged 2.3|Implementations will not raise an exception on writes of unsupported values to a *WARL* field.
Implementations can return any legal value on the read of a *WARL* field when the last write was of an
illegal value, but the legal value returned should deterministically depend on the illegal written value
and the architectural state of the hart.
|===

*** should there be a parameter about WLRL fields throwing illegal instruction when an illegal value is written?

=== Normative Rules

The testplan for each extension contains a list of normative rules applicable to that extension.
Normative rules are generally direct quotations from a ratified RISC-V specification describing a single certifiable feature.  They are associated
with an https://docs.asciidoctor.org/asciidoc/latest/attributes/id/[ID anchor] in the ASCIIDoc source of the spec.
Normative rules only apply to statements that could be measured by a test.  In particular, introductory overview and
non-normative explanatory text is not quoted as a normative rule.  For brevity, there are no normative rules
associated with instruction opcodes, CSR numbers, or similar encodings; these are tested when the instruction is
executed or CSR is accessed.

[NOTE]
====
Occasionally, the
rule is implicit in the specification, such as the artwork of a figure or the logical interaction of
multiple quotations from a spec.  Such rules are fabricated in this test plan, and supported by
references to figures or by a combination of quotations and some logical reasoning. *** link to an example where this is needed, if needed
====

=== Normative Rule IDs

Normative rule IDs follow the format defined in https://github.com/riscv-software-src/riscv-unified-db/blob/884-add-normative-rules-for-i-extension/tools/ruby-gems/udb/lib/udb/doc_link.rb[the UDB documentation]. <<t-normative-rules-ids>> provides examples

[[t-normative-rules-ids]]
.Normative Rule ID Examples
[cols="1, 1, 2" options=header]
|===
|Scenario|Example|Rule
|Instruction|`norm:inst:add:operation`|ADD performs the addition of _rs1_ and _rs2_.
|Several Instructions|`norm:insts:slt_sltu:operation`|SLT and SLTU perform signed and unsigned compares respectively, writing 1 to _rd_ if
_rs1_ < _rs2_, 0 otherwise.
|CSR|`norm:csr:hstatus:reg`|The hstatus register is an HSXLEN-bit read/write register formatted as shown in when HSXLEN=32 and when HSXLEN=64. The hstatus register provides facilities analogous to the mstatus register for tracking and controlling the exception behavior of a VS-mode guest.
|Several CSRs|`norm:csrs:sie_hip_hie:mutex`|For each writable bit in sie, the corresponding bit shall be read-only zero in both hip and hie. Hence, the nonzero bits in sie and hie are always mutually exclusive, and likewise for sip and hip.
|CSR bitfield|`norm:csrfld:hstatus:vsxl:op`|The VSXL field controls the effective XLEN for VS-mode (known as VSXLEN), which may differ from the XLEN for HS-mode (HSXLEN). When HSXLEN=32, the VSXL field does not exist, and VSXLEN=32. When HSXLEN=64, VSXL is a WARL field that is encoded the same as the MXL field of misa, shown in . In particular, an implementation may make VSXL be a read-only field whose value always ensures that VSXLEN=HSXLEN.
|Other behaviors not in the schema|`norm:ext:H:vscsrs-vs-perm`|When V=1, an attempt to read or write a VS CSR directly by its own separate CSR address causes a virtual-instruction exception.
|===

The following code snippets show how to tag the https://github.com/riscv/riscv-isa-manual/blob/main/src/rv32.adoc[spec].

Normative rule IDs can be applied to an entire paragraph with a `[[norm:...]]` ID.

```
[[norm:instgrp:load_store:endian_byte_operation]]
In a system for which endianness is byte-address invariant, the
following property holds: if a byte is stored to memory at some address
in some endianness, then a byte-sized load from that address in any
endianness returns the stored value.
```

Alternatively, they can be applied to a portion of a paragraph:
[literal]
#[#norm:...]#tagged text#

```
[#norm:inst:add:operation]#ADD performs the addition of _rs1_ and
_rs2_.#[#norm:inst:sub:operation]#SUB performs the subtraction of _rs2_ from _rs1_.#[#norm:insts:add_sub:overflow]#Overflows are ignored and the low XLEN bits of results are written to the destination _rd_.#
```

*** need to choose operation vs. op
*** level of detail: regularly subtag sentences or subsentence in a paragraph

=== Coverpoints

Coverpoints are written with one file that covers both RV32 and RV64, to reduce the duplication and risk of becoming out of sync.  When a coverage file contains coverpoints that apply only to one XLEN or the other (e.g. 32 or 64-bit edge values), they are separated by ``ifdef XLEN32` or `XLEN64` directives. Similarly, when a coverpoint applies only to a certain parameter value (PMP NA4 regions are not supported for granularity coarser than 4 bytes), they uses ``ifdef`` to exclude tests based on the parameter value.

=== Tests

Privileged tests are mostly written by hand and share a single .S file that can be compiled for either RV32 or RV64, again with `ifdef` directives to separate the two.  Unprivileged tests are generated from a template using a Python script, and are divided into RV32 and RV64 directories because the random values differ with XLEN.

*** no loops - each test should have a unique PC?
